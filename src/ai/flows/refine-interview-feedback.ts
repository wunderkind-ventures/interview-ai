'use server';
/**
 * @fileOverview A specialized AI flow to refine draft interview feedback.
 *
 * - refineInterviewFeedback - A function that takes draft feedback and interview context, returning refined feedback.
 * - RefineInterviewFeedbackInput - The input type for the refineInterviewFeedback function.
 * - RefineInterviewFeedbackOutput - The return type for the refineInterviewFeedback function.
 */

import { genkit } from 'genkit';
import { googleAI } from '@genkit-ai/googleai';
import { ai as globalAi } from '@/ai/genkit';
import {z} from 'genkit';
import { GenerateInterviewFeedbackOutputSchema } from '../schemas'; 
import type { GenerateInterviewFeedbackOutput } from '../schemas';

const InterviewContextSchema = z.object({
  interviewType: z.string(),
  interviewStyle: z.string(),
  faangLevel: z.string(),
  jobTitle: z.string().optional(),
  interviewFocus: z.string().optional(),
  timeWasTracked: z.boolean().describe("Indicates if timeTakenMs was generally available in the draft feedback items.")
});

const RefineInterviewFeedbackInputSchema = z.object({ // Not exported
  draftFeedback: GenerateInterviewFeedbackOutputSchema.describe(
    'The draft feedback generated by the initial feedback flow. This includes critiques, strengths, areas for improvement, suggestions, ideal pointers, confidence scores, and draft reflection prompts.'
  ),
  interviewContext: InterviewContextSchema.describe(
    'The original context of the interview.'
  ),
});
export type RefineInterviewFeedbackInput = z.infer<
  typeof RefineInterviewFeedbackInputSchema
>;

export type RefineInterviewFeedbackOutput = GenerateInterviewFeedbackOutput; 

// Extract the prompt template as a constant
const REFINE_FEEDBACK_PROMPT_TEMPLATE = `You are an Expert Feedback Polisher AI. Your task is to review and refine DRAFT interview feedback to make it exceptionally clear, concise, actionable, and supportive.
Pay special attention to polishing the 'reflectionPrompts'.

**Original Interview Context:**
- Type: {{interviewContext.interviewType}}
- Style: {{interviewContext.interviewStyle}}
- Level: {{interviewContext.faangLevel}}
{{#if interviewContext.jobTitle}}- Job Title: {{interviewContext.jobTitle}}{{/if}}
{{#if interviewContext.interviewFocus}}- Specific Focus: {{interviewContext.interviewFocus}}{{/if}}
{{#if interviewContext.timeWasTracked}}(Note: Time taken for answers was tracked and may be present in the draft feedback items.){{/if}}

**DRAFT Feedback for Review:**

**Overall Summary (Draft):**
"{{draftFeedback.overallSummary}}"

**Feedback Items (Draft):**
{{#each draftFeedback.feedbackItems}}
---
Question ID: {{this.questionId}}
Question: "{{this.questionText}}"
Answer: "{{this.answerText}}"
{{#if this.timeTakenMs}}(Time taken: {{this.timeTakenMs}} ms){{/if}}
{{#if this.confidenceScore}}(User Confidence: {{this.confidenceScore}}/5){{/if}}

Critique (Draft): "{{this.critique}}"
Strengths (Draft): {{#if this.strengths.length}}{{#each this.strengths}}
- "{{this}}"{{/each}}{{else}}None listed.{{/if}}
Areas for Improvement (Draft): {{#if this.areasForImprovement.length}}{{#each this.areasForImprovement}}
- "{{this}}"{{/each}}{{else}}None listed.{{/if}}
Specific Suggestions (Draft): {{#if this.specificSuggestions.length}}{{#each this.specificSuggestions}}
- "{{this}}"{{/each}}{{else}}None listed.{{/if}}
Ideal Answer Pointers (Draft): {{#if this.idealAnswerPointers.length}}{{#each this.idealAnswerPointers}}
- "{{this}}"{{/each}}{{else}}None listed.{{/if}}
Reflection Prompts (Draft): {{#if this.reflectionPrompts.length}}{{#each this.reflectionPrompts}}
- "{{this}}"{{/each}}{{else}}None listed.{{/if}}
---
{{/each}}

**Your Task: REFINE the draft feedback based on the following criteria.**
Your output MUST be in the same JSON format as the input 'draftFeedback' (keys 'feedbackItems' and 'overallSummary').
Do NOT simply repeat the draft. Provide tangible improvements.

1.  **Clarity & Conciseness:**
    *   Rephrase any jargon or overly complex sentences into simple, direct language.
    *   Eliminate redundancy. Ensure each point is distinct and impactful.
    *   The overall summary should be easy to grasp and provide a clear takeaway.

2.  **Tone:**
    *   Ensure the tone is consistently supportive, encouraging, and constructive. Avoid overly harsh or critical language.
    *   Frame 'areasForImprovement' as opportunities for growth and learning.

3.  **Actionability:**
    *   'SpecificSuggestions' must be highly practical and provide clear, actionable steps the candidate can take.
    *   'AreasForImprovement' should clearly identify what needs work, ideally with a hint towards how.

4.  **Reflection Prompts Polish:**
    *   Review the draft 'reflectionPrompts'. Ensure they are open-ended, encouraging, and genuinely help the user reflect on their answer in relation to their confidence and the AI's feedback.
    *   Make them more insightful and less generic if needed. Ensure they align well with the critique given for that specific answer.

5.  **Completeness & Relevance (Especially for Overall Summary):**
    *   **Pacing Check:** If 'interviewContext.timeWasTracked' is true, critically assess if the draft 'overallSummary' adequately comments on the candidate's pacing and time management. If this aspect is missing or too generic in the draft, enhance this part of the summary.
    *   **Focus Check:** If an 'interviewContext.interviewFocus' was provided, ensure the 'overallSummary' and relevant 'feedbackItems' explicitly address how well the candidate addressed this focus. If this is weak or missing in the draft, strengthen this aspect.
    *   Ensure all feedback components (critique, strengths, areas, suggestions, ideal pointers, reflectionPrompts) are well-developed, distinct, and insightful for each 'feedbackItem'. If any section in the draft feels underdeveloped, generic, or repetitive, enhance it.

6.  **Maintain Original IDs and Structure:**
    *   The 'questionId' for each feedback item must be preserved.
    *   The output must conform to the same JSON structure as the input 'draftFeedback'.

Return ONLY the refined JSON object.
`;

// Template customization function to replace placeholders with actual values
const customizeRefineFeedbackPromptText = (template: string, input: RefineInterviewFeedbackInput): string => {
  let promptText = template;
  
  // Replace interview context fields
  promptText = promptText.replace(/{{interviewContext\.interviewType}}/g, input.interviewContext.interviewType);
  promptText = promptText.replace(/{{interviewContext\.interviewStyle}}/g, input.interviewContext.interviewStyle);
  promptText = promptText.replace(/{{interviewContext\.faangLevel}}/g, input.interviewContext.faangLevel);
  
  // Handle optional jobTitle
  if (input.interviewContext.jobTitle) {
    promptText = promptText.replace(
      /{{#if interviewContext\.jobTitle}}- Job Title: {{interviewContext\.jobTitle}}{{\/if}}/g,
      `- Job Title: ${input.interviewContext.jobTitle}`
    );
  } else {
    promptText = promptText.replace(/{{#if interviewContext\.jobTitle}}[\s\S]*?{{\/if}}/g, '');
  }
  
  // Handle optional interviewFocus
  if (input.interviewContext.interviewFocus) {
    promptText = promptText.replace(
      /{{#if interviewContext\.interviewFocus}}- Specific Focus: {{interviewContext\.interviewFocus}}{{\/if}}/g,
      `- Specific Focus: ${input.interviewContext.interviewFocus}`
    );
  } else {
    promptText = promptText.replace(/{{#if interviewContext\.interviewFocus}}[\s\S]*?{{\/if}}/g, '');
  }
  
  // Handle timeWasTracked
  if (input.interviewContext.timeWasTracked) {
    promptText = promptText.replace(
      /{{#if interviewContext\.timeWasTracked}}\(Note: Time taken for answers was tracked and may be present in the draft feedback items\.\){{\/if}}/g,
      '(Note: Time taken for answers was tracked and may be present in the draft feedback items.)'
    );
  } else {
    promptText = promptText.replace(/{{#if interviewContext\.timeWasTracked}}[\s\S]*?{{\/if}}/g, '');
  }
  
  // Replace overall summary
  promptText = promptText.replace(/{{draftFeedback\.overallSummary}}/g, input.draftFeedback.overallSummary);
  
  // Handle feedback items
  const feedbackItemsText = input.draftFeedback.feedbackItems.map(item => {
    let itemText = `---
Question ID: ${item.questionId}
Question: "${item.questionText}"
Answer: "${item.answerText}"`;
    
    if (item.timeTakenMs !== undefined) {
      itemText += `\n(Time taken: ${item.timeTakenMs} ms)`;
    }
    
    if (item.confidenceScore !== undefined) {
      itemText += `\n(User Confidence: ${item.confidenceScore}/5)`;
    }
    
    itemText += `\n\nCritique (Draft): "${item.critique || 'None provided.'}"`;
    
    // Strengths
    if (item.strengths && item.strengths.length > 0) {
      itemText += '\nStrengths (Draft): ';
      itemText += item.strengths.map(s => `\n- "${s}"`).join('');
    } else {
      itemText += '\nStrengths (Draft): None listed.';
    }
    
    // Areas for Improvement
    if (item.areasForImprovement && item.areasForImprovement.length > 0) {
      itemText += '\nAreas for Improvement (Draft): ';
      itemText += item.areasForImprovement.map(a => `\n- "${a}"`).join('');
    } else {
      itemText += '\nAreas for Improvement (Draft): None listed.';
    }
    
    // Specific Suggestions
    if (item.specificSuggestions && item.specificSuggestions.length > 0) {
      itemText += '\nSpecific Suggestions (Draft): ';
      itemText += item.specificSuggestions.map(s => `\n- "${s}"`).join('');
    } else {
      itemText += '\nSpecific Suggestions (Draft): None listed.';
    }
    
    // Ideal Answer Pointers
    if (item.idealAnswerPointers && item.idealAnswerPointers.length > 0) {
      itemText += '\nIdeal Answer Pointers (Draft): ';
      itemText += item.idealAnswerPointers.map(p => `\n- "${p}"`).join('');
    } else {
      itemText += '\nIdeal Answer Pointers (Draft): None listed.';
    }
    
    // Reflection Prompts
    if (item.reflectionPrompts && item.reflectionPrompts.length > 0) {
      itemText += '\nReflection Prompts (Draft): ';
      itemText += item.reflectionPrompts.map(r => `\n- "${r}"`).join('');
    } else {
      itemText += '\nReflection Prompts (Draft): None listed.';
    }
    
    itemText += '\n---';
    return itemText;
  }).join('\n');
  
  promptText = promptText.replace(
    /{{#each draftFeedback\.feedbackItems}}[\s\S]*?{{\/each}}/g,
    feedbackItemsText
  );
  
  return promptText;
};

export async function refineInterviewFeedback(
  input: RefineInterviewFeedbackInput,
  options?: { aiInstance?: any; apiKey?: string } // Allow passing AI instance or API key
): Promise<RefineInterviewFeedbackOutput> {
  let activeAI = globalAi; // Default to global instance
  let isByokPath = false;

  if (options?.aiInstance) {
    activeAI = options.aiInstance;
    isByokPath = true;
    console.log("[BYOK] refineInterviewFeedback: Using provided aiInstance.");
  } else if (options?.apiKey) {
    try {
      activeAI = genkit({
        plugins: [googleAI({ apiKey: options.apiKey })],
        // No model here, it will be specified in generate call
      });
      isByokPath = true;
      console.log("[BYOK] refineInterviewFeedback: Using user-provided API key.");
    } catch (e) {
      console.warn(`[BYOK] refineInterviewFeedback: Failed to initialize Genkit with user-provided API key: ${(e as Error).message}. Falling back to default.`);
      // activeAI remains globalAi
    }
  } else {
    console.log("[BYOK] refineInterviewFeedback: No specific API key or AI instance provided; using default global AI instance.");
  }

  const processedDraftFeedback = {
    ...input.draftFeedback,
    feedbackItems: input.draftFeedback.feedbackItems.map(item => ({
      ...item,
      strengths: item.strengths || [],
      areasForImprovement: item.areasForImprovement || [],
      specificSuggestions: item.specificSuggestions || [],
      idealAnswerPointers: item.idealAnswerPointers || [],
      reflectionPrompts: item.reflectionPrompts || [],
    }))
  };

  const processedInput = { ...input, draftFeedback: processedDraftFeedback };

  try {
    let output: GenerateInterviewFeedbackOutput | null | undefined;
    
    if (isByokPath) {
      // BYOK path: use generate() with interpolated prompt
      const customizedPrompt = customizeRefineFeedbackPromptText(REFINE_FEEDBACK_PROMPT_TEMPLATE, processedInput);
      
      const result = await activeAI.generate<typeof GenerateInterviewFeedbackOutputSchema>({
        prompt: customizedPrompt,
        context: processedInput,
        model: googleAI.model('gemini-1.5-flash-latest'),
        output: { schema: GenerateInterviewFeedbackOutputSchema },
        config: { responseMimeType: "application/json" },
      });
      
      if (!result.output) {
        throw new Error('AI did not return refined feedback.');
      }
      
      output = result.output;
    } else {
      // Global path: use generate() with interpolated prompt
      const customizedPrompt = customizeRefineFeedbackPromptText(REFINE_FEEDBACK_PROMPT_TEMPLATE, processedInput);
      
      const result = await activeAI.generate<typeof GenerateInterviewFeedbackOutputSchema>({
        prompt: customizedPrompt,
        context: processedInput,
        model: googleAI.model('gemini-1.5-flash-latest'),
        output: { schema: GenerateInterviewFeedbackOutputSchema },
        config: { responseMimeType: "application/json" },
      });
      
      if (!result.output) {
        throw new Error('AI did not return refined feedback.');
      }
      
      output = result.output;
    }
    
    if (!output) {
      throw new Error('AI did not return refined feedback.');
    }
    
    const validatedOutput: RefineInterviewFeedbackOutput = {
        overallSummary: output.overallSummary,
        feedbackItems: output.feedbackItems.map(item => ({
            ...item,
            strengths: item.strengths || [],
            areasForImprovement: item.areasForImprovement || [],
            specificSuggestions: item.specificSuggestions || [],
            idealAnswerPointers: item.idealAnswerPointers || [],
            reflectionPrompts: item.reflectionPrompts || [],
        })),
    };
    return validatedOutput;
  } catch (error) {
    console.error("Error during feedback refinement:", error);
    throw error;
  }
}
